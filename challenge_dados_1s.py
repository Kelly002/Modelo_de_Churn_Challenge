# -*- coding: utf-8 -*-
"""challenge_dados_1S.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c5rMJw9QvpRItnbt3DnWDi3l-CfFPwtw
"""

# Importando os dados
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sys
sys.path.append('../')
import seaborn as sns
import matplotlib.pyplot as plt

from plotly.express import box
from sklearn.preprocessing import StandardScaler, LabelEncoder

"""# 1° Semana - Limpeza da base

Nessa primeira semana temos que buscar os dados que estão em formatos (dicionário e json) e tabelas distintas. Entender e interpretar cada valor que consta na tabela.

Fazer a análise estatística dos dados, utilizando gráficos e o que for necessário para extrair insights.

Fazer o tratamento de valores ausentes, nulos e dispares.

Realizar se necessário a engenharia de features e a normalização dos dados.

Finalizar a semana rodando um primeiro modelo de classificação.

## Carregando os dados
"""

# Carrega os dados
df = pd.read_json('https://challenge-data-science-3ed.s3.amazonaws.com/Telco-Customer-Churn.json')
df.head(5)

# Colunas existentes na base

df.columns

"""## Abrindo os dicionários de dados"""

# customerID: numero de identificao unico de cada cliente
# Esse campo possui dois tipos de dados distintos: numerico e alfanumerico

df['customerID']

# Churn: se o cliente deixou ou nao a empresa
# este campo é formado por: No, Yes e Vazio
df['Churn'].unique()

# customer: é um outro dicionário

# gender: genero (masculino e feminino)
# SeniorCitizen: informacao sobre um cliente ter ou nao idade igual ou maior que 65 anos
# Partner:  se o cliente possui ou nao um parceiro ou parceira
# Dependents: se o cliente possui ou nao dependentes
# tenure:  meses de contrato do cliente

df['customer'][0]

##############################################################################
#      Converte a coluna 'customer' que é um dicionário em um dataframe df1
##############################################################################

#gera uma lista com os valores da variável gender
gender = []
#gera uma lista com os valores da variável SeniorCitizen
senior =[]
#gera uma lista com os valores da variável Partner
partner = []
#gera uma lista com os valores da variável Dependents
dependent = []
#gera uma lista com os valores da variável tenure
tenure = []

for i in df['customer']:
  aux_gender = i['gender']
  aux_seior = i['SeniorCitizen']
  aux_partner = i['Partner']
  aux_dependent = i['Dependents']
  aux_tenure = i['tenure']
  gender.append(aux_gender)
  senior.append(aux_seior)
  partner.append(aux_partner)
  dependent.append(aux_dependent)
  tenure.append(aux_tenure)

# utiliza a função zip para gerar uma unica lista com todas os valores das saidas
aux = list(zip(gender,senior, partner,dependent, tenure))

# junta tudo em um único dataframe df1
df1 = pd.DataFrame(aux, columns = ['gender', 'SeniorCitizen', 'Partner', 'Dependents', 'tenure'])

# mostrta o dataframe gerado
df1.head()

# phone: é um outro dicionário

# PhoneService: assinatura de servico telefonico
# MultipleLines: assisnatura de mais de uma linha de telefone

#df['phone'][1]['PhoneService']
df['phone'][1]

##############################################################################
#      Converte a coluna 'phone' que é um dicionário em um dataframe df2
##############################################################################

#gera uma lista com os valores da variável PhoneService
service = []
#gera uma lista com os valores da variável MultipleLines
lines =[]

# percorre todo o diconário
for i in df['phone']:
  aux_service = i['PhoneService']
  aux_lines = i['MultipleLines']
  service.append(aux_service)
  lines.append(aux_lines)

# utiliza a função zip para gerar uma unica lista com todas os valores das saidas
aux = list(zip(service, lines))

# junta tudo em um único dataframe df1
df2 = pd.DataFrame(aux, columns = ['PhoneService', 'MultipleLines'])

df2.head()

# internet: é outro dicionário

# InternetService: assinatura de um provedor internet
# OnlineSecurity: assinatura adicional de seguranca online
# OnlineBackup: assinatura adicional de backup online
# DeviceProtection: assinatura adicional de protecao no dispositivo
# TechSupport: assinatura adicional de suporte tecnico, menos tempo de espera
# StreamingTV: assinatura de TV a cabo
# StreamingMovies: assinatura de streaming de filmes

df['internet'][1]

##############################################################################
#      Converte a coluna 'internet' que é um dicionário em um dataframe df3
##############################################################################

#gera uma lista com os valores da variável InternetService
internet = []
#gera uma lista com os valores da variável OnlineSecurity
security =[]
#gera uma lista com os valores da variável OnlineBackup
backup = []
#gera uma lista com os valores da variável DeviceProtection
protection = []
#gera uma lista com os valores da variável TechSupport
support = []
#gera uma lista com os valores da variável StreamingTV
streaming = []
#gera uma lista com os valores da variável StreamingMovies
movies = []

for i in df['internet']:
  aux_internet = i['InternetService']
  aux_security = i['OnlineSecurity']
  aux_backup = i['OnlineBackup']
  aux_protection = i['DeviceProtection']
  aux_support = i['TechSupport']
  aux_streaming = i['StreamingTV']
  aux_movies = i['StreamingMovies']
  internet.append(aux_internet)
  security.append(aux_security)
  backup.append(aux_backup)
  protection.append(aux_protection)
  support.append(aux_support)
  streaming.append(aux_streaming)
  movies.append(aux_movies)

# utiliza a função zip para gerar uma unica lista com todas os valores das saidas
aux = list(zip(internet,security, backup, protection, support, streaming, movies))

# junta tudo em um único dataframe df1
df3 = pd.DataFrame(aux, columns = ['InternetService', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies'])

df3.head()

# account é outro dicionário

# Contract: tipo de contrato
# PaperlessBillin: se o cliente prefere receber online a fatura
# PaymentMethod: forma de pagamento
# Charges.Monthly: total de todos os serviÃ§os do cliente por mÃªs

df['account'][0]

##############################################################################
#      Converte a coluna 'account' que é um dicionário em um dataframe df4
##############################################################################

#gera uma lista com os valores da variável Contract
contract = []
#gera uma lista com os valores da variável PaperlessBilling
biling =[]
#gera uma lista com os valores da variável PaymentMethod
method = []
#gera uma lista com os valores da variável Charges
charge = []

# percorre todo o dicionário
for i in df['account']:
  aux_contract = i['Contract']
  aux_biling = i['PaperlessBilling']
  aux_method = i['PaymentMethod']
  aux_charge = i['Charges']
  contract.append('aux_contract')
  biling.append(aux_biling)
  method.append(aux_method)
  charge.append(aux_charge)

# utiliza a função zip para gerar uma unica lista com todas os valores das saidas
aux = list(zip(contract, biling, method, charge))

# junta tudo em um único dataframe df1
df4 = pd.DataFrame(aux, columns = ['Contract', 'PaperlessBilling', 'PaymentMethod', 'Charges'])

df4.head()

# O 'Charges' é um outro dicionario

df4['Charges'][0]

##############################################################################
#      Converte a Contract 'Charges' que é um dicionário em um dataframe df5
##############################################################################

#gera uma lista com os valores da variável Monthly
month = []
#gera uma lista com os valores da variável Total
total =[]

# percorre todo o diconário
for i in df4['Charges']:
  aux_month = i['Monthly']
  aux_total = i['Total']
  month.append(aux_month)
  total.append(aux_total)

# utiliza a função zip para gerar uma unica lista com todas os valores das saidas
aux = list(zip(month, total))

# junta tudo em um único dataframe df1
df5 = pd.DataFrame(aux, columns = ['Monthly', 'Total'])

df5.head()

"""Todo esse processo que fiz abrindo uma tabela por vez poderia ser minimizado utilizando o método normalize"""

## importa a biblioteca
# import json

## coloca os dados em f
# with open('../Dados/Telco-Customer-Churn.json', 'r') as f:

## normaliza os dados que estão em f, trazendo todos os valores dos dicionários para colunas únicas
# dados = json.load(f)

"""## Juntando os dataframes gerados em um único"""

# Verifica o tamanho de todos os dataframes gerados

print(len(df))
print(len(df['customerID']))
print(len(df['Churn']))
print(len(df1))
print(len(df2))
print(len(df3))
print(len(df4))
print(len(df5))

# Junta todos os dataframes com a função concat

df_final = pd.concat([df['customerID'], df['Churn'],df1, df2, df3,  df4, df5], axis = 1, join='inner')
df_final.head(3)

# Verifica o tamanho do dataframe final gerado

len(df_final)

# Verifica as colunas do dataframe final gerado

df_final.columns

# Vamos deletar a coluna 'Charges' pois, suas informações estão nas colunas 'Monthly', 'Total'

df_final.drop(columns='Charges', axis = 1, inplace = True)

# Verifica os tipos dos dados do novo dataframe

df_final.info()

# Salva o novo dataframe em um csv
# Retira o index pra não ser gerado dois na leitura

df_final.to_csv('churn.csv', index=False)

"""## Analisando os dados"""

# Faz a leitura do arquivo que foi salvo em .csv

churn = pd.read_csv('churn.csv')
churn.head()

# Tipagem dos dados

churn.info()

# Mostra as medidas estatísticas, das variavies numericas

# inclui as medidas estatísticas dos dados categóricos nas análises mas, algumas informações são perdidas com isso.
#churn.describe(include = [object].)T

churn.describe()

# Imprime quais são e quantos são os valores únicos de cada coluna

# gera uma lista com as coluna do dataframe
lista_colunas = churn.columns

# imprime a quantridade de valores números e quias são eles
for i in lista_colunas:
  print('**************')
  print(f'Quantidade de valores únicos:', len(churn[i].unique()))
  print(f'Valores únicos da coluna:', i , churn[i].unique())

"""## Traduzindo as colunas

1) 'customerID': identificar único da opração

2) 'Churn': Yes se houve o churn, No caso contrário

3) 'gender': 'Female' se feminino e 'Male' se masculino

4) 'SeniorCitizen': '1' se o cliente for maior que 65 anos e '0' caso contrário

5) 'Partner': 'Yes'se o cliente possui um parceiro 'No' caso contrário

6) 'Dependents': 'Yes' se possui dependente e 'No' se não possui dependente

7) 'tenure': tempo do contrato em meses

8) 'PhoneService': Yes se possui telefone de serviço e No caso contrário

9) 'MultipleLines': 'No' se não possui vários telefone de serviço, 'Yes' se possui vários telefone de serviço e 'No phone service' se não possui telefone.

10) 'InternetService': os tipos de serviços que o cliente possui:'DSL', 'Fiber optic' e 'No' não possui

11) 'OnlineSecurity': 'Yes' se assinatura adicional de seguranaçã online, 'No' caso contrário e 'No internet service' se o cliente não possuir o serviço.

12) 'OnlineBackup': 'Yes' se possuir assinatura adicional de backup online, 'No' caso contrário e 'No internet service' se o cliente não possuir o serviço.

13) 'DeviceProtection': 'Yes' se possuir assinatura adicional de proteção no dispositivo, 'No' caso contrário e 'No internet service' se o cliente não possuir o serviço.

14) 'TechSupport': 'Yes' se possuir assinatura adicional de suporte técnico, menos tempo de espera, 'No' caso contrário e 'No internet service' se o cliente não possuir o serviço.

15) 'StreamingTV': 'Yes' se possuir assinatura de TV a cabo, 'No' caso contrário e 'No internet service' se o cliente não possuir o serviço.

16) 'StreamingMovies':'Yes' se possuir assinatura de streaming de filmes, 'No' caso contrário e 'No internet service' se o cliente não possuir o serviço.

17) 'Contract': 'aux_contract' descreve o tipo de contrato

18) 'PaperlessBilling': 'Yes' se o cliente prefere receber online a fatura e 'No' caso contrário.

19) 'PaymentMethod': forma de pagamento como: 'Mailed check' 'Electronic check' 'Credit card (automatic)', 'Bank transfer (automatic)'

20) 'Monthly': 1585 valores distintos para descrever o total de todos os servições do cliente por mês

21) 'Total': 6531 valores distintos para descrvere o total gasto pelo cliente.
"""

churn.info()

# vamos separar as colunas numericas e categóricas

# cria uma lista com as colunas que são do tipo numerica
variavel_numerica = []
# cria uma lista com as colunas que são do tipo categorica
variavel_categorica = []

for i in churn.columns.tolist():
  if churn.dtypes[i] == 'object':
    variavel_categorica.append(i)
  else:
    variavel_numerica.append(i)

"""## Analise estatística das variáveis

Variáveis numéricas: vamos analisar as variáveis numéricas vamos fazer o box plot dos dados
"""

variavel_numerica

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [8,3]
plt.rcParams["figure.autolayout"] = np.True_

for col in ['tenure', 'Monthly' ]:
  sns.boxplot(data = churn, x=col, y ='Churn')
  plt.title(f"Boxplot de {col} por Churn", fontsize=15)
  plt.show()

"""Para o primeiro conjuto de dados podemos concluir que os clientes que estão a mais tempo tendem a continuar utilizando o serviço.

Já para o segundo caso, clientes que possuem serviços mais baratos, tendem a continuar utilizando o serviço.
"""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [5,3]
plt.rcParams["figure.autolayout"] = np.True_

# definindo os subplots
f, axes = plt.subplots(1,3)

# coloca cada informação em um plot distinto
sns.boxplot(data = churn, y =churn['tenure'], ax = axes[1])
sns.boxplot(data = churn, y =churn['Monthly'], ax = axes[2])
plt.show()

# para os valores numéricos podemos perceber que não existem autliers
# o tempo máximo de contratação é de 70 meses e a média é de 30 meses, sendo 10 meses o prazo minimo. Neste caso tb, podemos reescrever a variável em faixas de valores
# Como a variével "Monthly" possui muitos valores distintos, vamos reescreva-la em faixas de valores

"""Variáveis categóricas: para analisar vamos fazer gráficos de dispersão"""

variavel_categorica

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [10,3]
plt.rcParams["figure.autolayout"] = np.True_

# definindo os subplots
f, axes = plt.subplots(1,5)

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['customerID'], ax = axes[0])
sns.countplot(data = churn, x =churn['Churn'], ax = axes[1])
sns.countplot(data = churn, x =churn['gender'], ax = axes[2])
sns.countplot(data = churn, x =churn['Partner'], ax = axes[3])
sns.countplot(data = churn, x =churn['Dependents'], ax = axes[4])
plt.show()

"""Como o customerID é um identifocador único, vamos retira-lo da base.

Podemos percebre que a variável "Churn" é desbalanceada.

O mesmo acontece com a variável "Dependente"
"""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [5,3]

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['gender'], hue='Churn')

plt.show()

"""Aqui, podemos notar que não faz diferença ser do sexo feminino ou masculino para que aconteça o Churn. A distribuição é a mesma para os dois casos."""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [18,3]
plt.rcParams["figure.autolayout"] = np.True_

# definindo os subplots
f, axes = plt.subplots(1,5)

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['PhoneService'], ax = axes[0])
sns.countplot(data = churn, x =churn['MultipleLines'], ax = axes[1])
sns.countplot(data = churn, x =churn['InternetService'], ax = axes[2])
sns.countplot(data = churn, x =churn['OnlineSecurity'], ax = axes[3])
sns.countplot(data = churn, x =churn['OnlineBackup'], ax = axes[4])
plt.show()

"""
Podemos percebre que a variável "phoneSErvice" é desbalanceada"""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [5,3]

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['InternetService'], hue='Churn')

plt.show()

"""Neste caso,  podemos perceber que a Internet de Fibra Ótica possui mais casos de Churn.

Já o DSL é o caso que possui menos casos de Churn. Logo, a empresa poderia ofertar mais esse tipo de produto.

A empresa também poderia tentar identificar quais os problemas que causam esse numéro elevado de Churn na Fibra Ótica.
"""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [10,3]

# definindo os subplots
f, axes = plt.subplots(1,2)

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['OnlineSecurity'], hue='Churn', ax=axes[0])
sns.countplot(data = churn, x =churn['OnlineBackup'], hue='Churn', ax=axes[1])

plt.show()

"""De acordo com os dois gráficos podeos concluir que os cliente que não possuem o Serviço Online de Segurança e o Backup tendem a ter um número maior de Churn.

Logo, oferecer esses dois serviços seria uma boa opçõa para reduzir a taxa de cancelamneto.
"""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [8,3]

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['DeviceProtection'], hue='Churn')

plt.show()

"""A mesma coisa acontece para com os clientes que não possuem a proteção do Device.

Uma boa alternativa, é oferta a venda desse produto para diminuir a taxa de cancelamentos também.
"""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [5,3]

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['TechSupport'], hue='Churn')

plt.show()

"""Clientes que não possuem um serviço técnico tendem também a deixar a empresa."""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [5,3]

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['Contract'], hue='Churn')

plt.show()

"""Clientes que possuem contrato mensal são os que tendem a deixar a empresa. Ou seja, oferecer contrato anual ou de dois anos são as melhores opções."""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [15,3]

# definindo os subplots
f, axes = plt.subplots(1,2)

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['PaperlessBilling'], hue='Churn', ax=axes[0])
sns.countplot(data = churn, x =churn['PaymentMethod'], hue='Churn', ax=axes[1])

plt.show()

"""Percebemos que as pessoas utilizam o método de pagamento "Eletronic check" tendem a cancelar os serviços da empresa. Direcionar os clientes para outro método de pagamento é uma boa opção para reduzir a taxa de cancelamentos, como por exemplo cartão de crédito que é onde tem a menor taxa de cancelamento."""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [5,3]

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['SeniorCitizen'], hue='Churn')

plt.show()

"""Apesar da quantidade de clientes idosos ser bem menor, a proporção de clientes que cancelaram o serviço entre os idosos é maior que a de clientes que não são idosos. Entender os motivos que estão levando a essa taxa de cancelamento entre os idosos e adotar medidas para melhorar o serviço para esses clientes é uma boa opção para reduzir a taxa de cancelamento."""

# definie o tamanho dos gráficos
plt.rcParams["figure.figsize"] = [18,3]
plt.rcParams["figure.autolayout"] = np.True_

# definindo os subplots
f, axes = plt.subplots(1,3)

# coloca cada informação em um plot distinto
sns.countplot(data = churn, x =churn['PaperlessBilling'], ax = axes[0])
sns.countplot(data = churn, x =churn['PaymentMethod'], ax = axes[1])
sns.countplot(data = churn, x =churn['Total'], ax = axes[2])
plt.show()

"""Como a variável "Total" possui muitos valores, vamos reescreve-la em faixas de valores

## Correlação dos dados
"""

plt.figure(figsize=(5, 5))
sns.heatmap(churn.corr(), annot = False, cmap='seismic')
plt.title('Correlação entre as variáveis')
plt.show()

# salva a imagem em um arquivo PNG
#plt.savefig('corr_heatmap.png')

"""As variáveis "tenue" e "Senior" são correlacionadas, ou seja, ambas carregam o mesmo tipo de informação. Logo, trabalhar apenas com uma delas, descartando a outra."""

# Salva a nova base dos dados em um csv
# Retira o index pra não ser gerado dois indeces na leitura

churn.to_csv('churn.csv', index=False)